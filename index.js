require('dotenv').config();
const { Client, GatewayIntentBits, Collection, Partials } = require('discord.js');
const keepAlive = require('./server.js');

// Create Discord client
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.DirectMessages,
    GatewayIntentBits.GuildMessageReactions
  ],
  partials: [Partials.Channel, Partials.Message, Partials.Reaction]
});

const PREFIX = '!'; // Thay ƒë·ªïi prefix th√†nh !

// Collections for cooldowns and user data
client.cooldowns = {
  pvp: new Collection(),
  bikip: new Collection(),
  tuluyen: new Collection(),
  duocvien: new Collection(),
  linhthu: new Collection(),
  bicanh: new Collection(),
  boss: new Collection()
};

client.userData = new Collection();

// Cooldown times in milliseconds
const COOLDOWNS = {
  pvp: 5 * 60 * 1000,        // 5 minutes
  bikip: 2 * 60 * 60 * 1000, // 2 hours
  tuluyen: 60 * 60 * 1000,   // 1 hour
  duocvien: 30 * 60 * 1000,  // 30 minutes
  linhthu: 24 * 60 * 60 * 1000,  // 24 hours
  bicanh: 6 * 60 * 60 * 1000,    // 6 hours
  boss: 0  // No cooldown for viewing boss
};

// C·∫£nh gi·ªõi tu ti√™n
const CANH_GIOI = [
  'Ph√†m Nh√¢n',
  'Luy·ªán Kh√≠',
  'Tr√∫c C∆°',
  'Kim ƒêan',
  'Nguy√™n Anh',
  'H√≥a Th·∫ßn',
  'Luy·ªán H∆∞',
  'H·ª£p Th·ªÉ',
  'ƒê·∫°i Th·ª´a',
  'ƒê·ªô Ki·∫øp'
];

// Boss system
const bosses = {
  current: null,
  hits: 0,
  maxHits: 10,
  types: [
    'Huy·∫øt Nguy·ªát Ma V∆∞∆°ng',
    'Thi√™n Ngo·∫°i T√† Ti√™n',
    'C·ªï Ti√™n Th√°nh Th√∫'
  ]
};

// Th√™m h·ªá th·ªëng linh th√∫
const LINH_THU_TYPES = {
  'H·ªèa K·ª≥ L√¢n': { power: 100, element: 'h·ªèa' },
  'BƒÉng Ph∆∞·ª£ng Ho√†ng': { power: 100, element: 'bƒÉng' },
  'L√¥i Long': { power: 100, element: 'l√¥i' },
  'M·ªôc Quy': { power: 100, element: 'm·ªôc' },
  'Th·ªï Nham Th√∫': { power: 100, element: 'th·ªï' }
};

// Check cooldown function
function checkCooldown(userId, command) {
  const cooldownTime = COOLDOWNS[command];
  const timestamps = client.cooldowns[command];
  
  if (timestamps.has(userId)) {
    const expirationTime = timestamps.get(userId) + cooldownTime;
    if (Date.now() < expirationTime) {
      const timeLeft = (expirationTime - Date.now()) / 1000;
      return Math.round(timeLeft);
    }
  }
  return 0;
}

// Get or create user data
function getUserData(userId) {
  if (!client.userData.has(userId)) {
    client.userData.set(userId, {
      level: 1,
      exp: 0,
      coins: 100,
      items: [],
      canhGioi: CANH_GIOI[0],
      linhThu: null  // Th√™m tr∆∞·ªùng linhThu
    });
  }
  return client.userData.get(userId);
}

// Spawn boss every 30 minutes
function spawnBoss() {
  if (!bosses.current) {
    bosses.current = bosses.types[Math.floor(Math.random() * bosses.types.length)];
    bosses.hits = 0;
    client.guilds.cache.forEach(guild => {
      const channel = guild.channels.cache.find(ch => 
        ch.name.includes('boss') || ch.name.includes('general') || ch.name.includes('chung')
      );
      if (channel) {
        channel.send(`üî• BOSS ${bosses.current} ƒë√£ xu·∫•t hi·ªán! H√£y s·ª≠ d·ª•ng tu!attack ƒë·ªÉ t·∫•n c√¥ng!`);
      }
    });
  }
}

client.on('ready', () => {
  console.log(`ƒêƒÉng nh·∫≠p th√†nh c√¥ng: ${client.user.tag}!`);
  // Start boss spawn timer
  setInterval(spawnBoss, 30 * 60 * 1000); // Every 30 minutes
  spawnBoss(); // Spawn first boss immediately
});

client.on('messageCreate', async message => {
  if (message.author.bot) return;
  if (!message.content.startsWith(PREFIX)) return;

  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  const command = args.shift().toLowerCase();

  try {
    switch(command) {
      case 'batdau':
        handleStartCommand(message);
        break;
      case 'trangthai':
        handleStatusCommand(message);
        break;
      case 'tu':
        handleTuLuyenCommand(message);
        break;
      case 'pvp':
        handlePvPCommand(message, args);
        break;
      case 'bikip':
        handleBiKipCommand(message);
        break;
      case 'haithuoc':
        handleDuocVienCommand(message);
        break;
      case 'linhthu':
        handleLinhThuCommand(message);
        break;
      case 'thonphe':
        handleThonPheCommand(message);
        break;
      case 'thongthu':
        handleLinhThuInfoCommand(message);
        break;
      case 'bicanh':
        handleBiCanhCommand(message);
        break;
      case 'boss':
        handleBossCommand(message);
        break;
      case 'danhboss':
        handleAttackBossCommand(message);
        break;
      case 'trogiup':
        handleHelpCommand(message);
        break;
    }
  } catch (error) {
    console.error(error);
    message.reply('‚ùå C√≥ l·ªói x·∫£y ra khi th·ª±c hi·ªán l·ªánh.');
  }
});

function handleStartCommand(message) {
  const userId = message.author.id;
  if (client.userData.has(userId)) {
    message.reply('‚ùå Ng∆∞∆°i ƒë√£ ƒëƒÉng k√Ω tu ti√™n r·ªìi! H√£y d√πng tu!status ƒë·ªÉ xem th√¥ng tin.');
    return;
  }

  client.userData.set(userId, {
    level: 1,
    exp: 0,
    coins: 100,
    items: [],
    canhGioi: CANH_GIOI[0]
  });

  message.reply(`
üéä Ch√†o m·ª´ng ${message.author.username} b∆∞·ªõc v√†o con ƒë∆∞·ªùng tu ti√™n!

üìù **Th√¥ng tin c∆° b·∫£n:**
üî∞ C·∫£nh gi·ªõi: ${CANH_GIOI[0]}
üí∞ Ti·ªÅn: 100
üìä EXP: 0/100

‚ùì D√πng tu!help ƒë·ªÉ xem h∆∞·ªõng d·∫´n chi ti·∫øt
  `);
}

function handleStatusCommand(message) {
  const userId = message.author.id;
  const userData = getUserData(userId);
  
  if (!userData) {
    message.reply('‚ùå Ng∆∞∆°i ch∆∞a b·∫Øt ƒë·∫ßu tu ti√™n! H√£y d√πng !batdau ƒë·ªÉ ƒëƒÉng k√Ω.');
    return;
  }

  const nextLevel = userData.level * 100;
  
  const statusEmbed = `
**üîÆ B·∫£ng Th√¥ng Tin Tu Ti√™n**
üë§ ƒê·∫°o h·ªØu: ${message.author.username}
‚≠ê C·∫£nh gi·ªõi: ${CANH_GIOI[userData.level - 1]}
üìä Tu vi: ${userData.exp}/${nextLevel}
üí∞ Linh th·∫°ch: ${userData.coins}

**‚è≥ Th·ªùi gian ch·ªù:**
‚öîÔ∏è PvP: ${formatCooldown(checkCooldown(userId, 'pvp'))}
üìö H·ªçc b√≠ k√≠p: ${formatCooldown(checkCooldown(userId, 'bikip'))}
üßò Tu luy·ªán: ${formatCooldown(checkCooldown(userId, 'tuluyen'))}
üåø H√°i thu·ªëc: ${formatCooldown(checkCooldown(userId, 'duocvien'))}
üêâ Thu ph·ª•c: ${formatCooldown(checkCooldown(userId, 'linhthu'))}
üèØ Kh√°m ph√°: ${formatCooldown(checkCooldown(userId, 'bicanh'))}
`;

  message.reply(statusEmbed);
}

function handleHelpCommand(message) {
  const helpText = `
**üìú H∆∞·ªõng D·∫´n Tu Ti√™n**

üéÆ **L·ªánh c∆° b·∫£n:**
!batdau - B·∫Øt ƒë·∫ßu con ƒë∆∞·ªùng tu ti√™n
!trangthai - Xem th√¥ng tin tu vi
!trogiup - Xem h∆∞·ªõng d·∫´n

üßò **Tu luy·ªán & Ph√°t tri·ªÉn:**
!tu - Tu luy·ªán tƒÉng exp (1h/l·∫ßn)
!bikip - H·ªçc b√≠ k√≠p (30p/l·∫ßn)
!haithuoc - H√°i thu·ªëc (30p/l·∫ßn)

üåç **Th√°m hi·ªÉm:**
!linhthu - Thu ph·ª•c linh th√∫ (24h/l·∫ßn)
!bicanh - Kh√°m ph√° b√≠ c·∫£nh (24h/l·∫ßn)

‚öîÔ∏è **Chi·∫øn ƒë·∫•u:**
!pvp @ng∆∞·ªùi_ch∆°i - Lu·∫≠n b√†n v·ªõi ƒë·∫°o h·ªØu (5p/l·∫ßn)
!boss - Xem th√¥ng tin boss
!danhboss - T·∫•n c√¥ng boss (3 l·∫ßn/boss)

üí° **L∆∞u √Ω:**
- Boss xu·∫•t hi·ªán m·ªói 30 ph√∫t
- M·ªói ng∆∞·ªùi ƒë∆∞·ª£c ƒë√°nh boss 3 l·∫ßn
- Boss c·∫ßn 10 l·∫ßn t·∫•n c√¥ng ƒë·ªÉ h·∫° g·ª•c
- Ng∆∞·ªùi k·∫øt li·ªÖu boss nh·∫≠n ph·∫ßn th∆∞·ªüng ƒë·∫∑c bi·ªát
`;
  message.reply(helpText);
}

// Boss command handlers
function handleBossCommand(message) {
  if (!bosses.current) {
    message.reply('Hi·ªán t·∫°i kh√¥ng c√≥ Boss n√†o xu·∫•t hi·ªán.');
    return;
  }
  
  message.reply(`Boss hi·ªán t·∫°i: ${bosses.current}\nS·ªë ƒë√≤n ƒë√£ ch·ªãu: ${bosses.hits}/${bosses.maxHits}`);
}

function handleAttackBossCommand(message) {
  if (!bosses.current) {
    message.reply('Kh√¥ng c√≥ Boss n√†o ƒë·ªÉ t·∫•n c√¥ng.');
    return;
  }

  const userId = message.author.id;
  const userHits = client.cooldowns.boss.get(userId) || 0;

  if (userHits >= 3) {
    message.reply('B·∫°n ƒë√£ h·∫øt l∆∞·ª£t t·∫•n c√¥ng Boss h√¥m nay.');
    return;
  }

  bosses.hits++;
  client.cooldowns.boss.set(userId, userHits + 1);

  if (bosses.hits >= bosses.maxHits) {
    message.reply(`üéâ Ch√∫c m·ª´ng! B·∫°n ƒë√£ k·∫øt li·ªÖu ${bosses.current}!\nüíé Ph·∫ßn th∆∞·ªüng ƒë·∫∑c bi·ªát ƒë√£ ƒë∆∞·ª£c trao t·∫∑ng.`);
    bosses.current = null;
    bosses.hits = 0;
    // Spawn new boss after 5 minutes
    setTimeout(spawnBoss, 5 * 60 * 1000);
  } else {
    message.reply(`‚öîÔ∏è T·∫•n c√¥ng th√†nh c√¥ng! Boss c√≤n ${bosses.maxHits - bosses.hits} ƒë√≤n n·ªØa s·∫Ω g·ª•c.`);
  }
}

function handleTuLuyenCommand(message) {
  const userId = message.author.id;
  const cooldownTime = checkCooldown(userId, 'tuluyen');
  
  if (cooldownTime > 0) {
    const minutes = Math.floor(cooldownTime / 60);
    const seconds = cooldownTime % 60;
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${minutes}p${seconds}s n·ªØa ƒë·ªÉ tu luy·ªán ti·∫øp.`);
    return;
  }

  const userData = getUserData(userId);
  const expGain = Math.floor(Math.random() * 50) + 50;
  userData.exp += expGain;
  
  if (userData.exp >= userData.level * 100) {
    userData.level += 1;
    userData.exp = 0;
    message.reply(`üéä Ch√∫c m·ª´ng! B·∫°n ƒë√£ ƒë·ªôt ph√° l√™n c·∫£nh gi·ªõi ${userData.level}!\nüí™ Tu vi tƒÉng m·∫°nh!`);
  } else {
    message.reply(`‚ö° Tu luy·ªán th√†nh c√¥ng!\nüìä EXP +${expGain}\nüîã EXP hi·ªán t·∫°i: ${userData.exp}/${userData.level * 100}`);
  }

  client.cooldowns.tuluyen.set(userId, Date.now());
}

function handlePvPCommand(message, args) {
  const userId = message.author.id;
  const cooldownTime = checkCooldown(userId, 'pvp');
  
  if (cooldownTime > 0) {
    const minutes = Math.floor(cooldownTime / 60);
    const seconds = cooldownTime % 60;
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${minutes}p${seconds}s n·ªØa ƒë·ªÉ PvP ti·∫øp.`);
    return;
  }

  const target = message.mentions.users.first();
  if (!target) {
    message.reply('Vui l√≤ng tag ng∆∞·ªùi ch∆°i b·∫°n mu·ªën th√°ch ƒë·∫•u. V√≠ d·ª•: !pvp @t√™n_ng∆∞·ªùi_ch∆°i');
    return;
  }

  if (target.bot) {
    message.reply('Kh√¥ng th·ªÉ th√°ch ƒë·∫•u v·ªõi bot!');
    return;
  }

  const userData = getUserData(userId);
  const targetData = getUserData(target.id);

  // T√≠nh s·ª©c m·∫°nh c∆° b·∫£n c·ªßa ng∆∞·ªùi ch∆°i
  const baseUserPower = userData.level * (Math.random() + 0.5);
  const baseTargetPower = targetData.level * (Math.random() + 0.5);

  // T√≠nh th√™m s·ª©c m·∫°nh t·ª´ linh th√∫
  let userBeastPower = 0;
  let targetBeastPower = 0;

  if (userData.linhThu) {
    userBeastPower = userData.linhThu.power * 0.3; // Linh th√∫ ƒë√≥ng g√≥p 30% s·ª©c m·∫°nh
  }
  if (targetData.linhThu) {
    targetBeastPower = targetData.linhThu.power * 0.3;
  }

  // T·ªïng s·ª©c m·∫°nh
  const totalUserPower = baseUserPower + userBeastPower;
  const totalTargetPower = baseTargetPower + targetBeastPower;

  let result;
  if (totalUserPower > totalTargetPower) {
    result = `üèÜ ${message.author} ƒë√£ chi·∫øn th·∫Øng ${target}!\n` +
             `üí™ S·ª©c m·∫°nh: ${totalUserPower.toFixed(1)} > ${totalTargetPower.toFixed(1)}\n` +
             `üìä Chi ti·∫øt:\n` +
             `üë§ ${message.author.username}: ${baseUserPower.toFixed(1)} + ${userBeastPower.toFixed(1)} (Linh th√∫)\n` +
             `üë§ ${target.username}: ${baseTargetPower.toFixed(1)} + ${targetBeastPower.toFixed(1)} (Linh th√∫)`;
    userData.coins += 100;
  } else {
    result = `üíÄ ${message.author} ƒë√£ thua ${target}!\n` +
             `üí™ S·ª©c m·∫°nh: ${totalUserPower.toFixed(1)} < ${totalTargetPower.toFixed(1)}\n` +
             `üìä Chi ti·∫øt:\n` +
             `üë§ ${message.author.username}: ${baseUserPower.toFixed(1)} + ${userBeastPower.toFixed(1)} (Linh th√∫)\n` +
             `üë§ ${target.username}: ${baseTargetPower.toFixed(1)} + ${targetBeastPower.toFixed(1)} (Linh th√∫)`;
  }

  message.reply(result);
  client.cooldowns.pvp.set(userId, Date.now());
}

function handleBiKipCommand(message) {
  const userId = message.author.id;
  const cooldownTime = checkCooldown(userId, 'bikip');
  
  if (cooldownTime > 0) {
    const minutes = Math.floor(cooldownTime / 60);
    const seconds = cooldownTime % 60;
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${minutes}p${seconds}s n·ªØa ƒë·ªÉ h·ªçc b√≠ k√≠p ti·∫øp.`);
    return;
  }

  const userData = getUserData(userId);
  const expGain = Math.floor(Math.random() * 30) + 20;
  userData.exp += expGain;
  
  message.reply(`üìö H·ªçc b√≠ k√≠p th√†nh c√¥ng!\nüìä EXP +${expGain}\nüîã EXP hi·ªán t·∫°i: ${userData.exp}/${userData.level * 100}`);
  client.cooldowns.bikip.set(userId, Date.now());
}

function handleDuocVienCommand(message) {
  const userId = message.author.id;
  const cooldownTime = checkCooldown(userId, 'duocvien');
  
  if (cooldownTime > 0) {
    const minutes = Math.floor(cooldownTime / 60);
    const seconds = cooldownTime % 60;
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${minutes}p${seconds}s n·ªØa ƒë·ªÉ h√°i d∆∞·ª£c vi√™n ti·∫øp.`);
    return;
  }

  const userData = getUserData(userId);
  const coins = Math.floor(Math.random() * 50) + 50;
  userData.coins += coins;
  
  message.reply(`üåø H√°i d∆∞·ª£c vi√™n th√†nh c√¥ng!\nüí∞ Coins +${coins}\nüëõ Coins hi·ªán t·∫°i: ${userData.coins}`);
  client.cooldowns.duocvien.set(userId, Date.now());
}

function handleLinhThuCommand(message) {
  const userId = message.author.id;
  const userData = getUserData(userId);
  
  // Ki·ªÉm tra n·∫øu ƒë√£ c√≥ linh th√∫
  if (userData.linhThu) {
    message.reply(`üêæ B·∫°n ƒë√£ c√≥ ${userData.linhThu.name} (C·∫•p ${userData.linhThu.level}) r·ªìi!\nD√πng !thonphe ƒë·ªÉ t√¨m linh th√∫ kh√°c th√¥n ph·ªá.`);
    return;
  }

  const cooldownTime = checkCooldown(userId, 'linhthu');
  if (cooldownTime > 0) {
    const hours = Math.floor(cooldownTime / 3600);
    const minutes = Math.floor((cooldownTime % 3600) / 60);
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${hours}h${minutes}m n·ªØa ƒë·ªÉ thu ph·ª•c linh th√∫ ti·∫øp.`);
    return;
  }

  const success = Math.random() < 0.5;
  if (success) {
    // Ch·ªçn ng·∫´u nhi√™n m·ªôt lo·∫°i linh th√∫
    const linhThuTypes = Object.keys(LINH_THU_TYPES);
    const randomType = linhThuTypes[Math.floor(Math.random() * linhThuTypes.length)];
    const linhThuInfo = LINH_THU_TYPES[randomType];
    
    // T·∫°o linh th√∫ m·ªõi
    userData.linhThu = {
      name: randomType,
      level: 1,
      exp: 0,
      element: linhThuInfo.element,
      power: linhThuInfo.power
    };

    const expGain = Math.floor(Math.random() * 100) + 100;
    userData.exp += expGain;
    message.reply(`üêâ Thu ph·ª•c linh th√∫ th√†nh c√¥ng!\nüéä B·∫°n ƒë√£ thu ph·ª•c ƒë∆∞·ª£c ${randomType} (${linhThuInfo.element})!\nüìä EXP +${expGain}\nüîã EXP hi·ªán t·∫°i: ${userData.exp}/${userData.level * 100}`);
  } else {
    message.reply('‚ùå Thu ph·ª•c linh th√∫ th·∫•t b·∫°i! H√£y th·ª≠ l·∫°i sau 24 gi·ªù.');
  }
  
  client.cooldowns.linhthu.set(userId, Date.now());
}

function handleThonPheCommand(message) {
  const userId = message.author.id;
  const userData = getUserData(userId);

  if (!userData.linhThu) {
    message.reply('‚ùå B·∫°n ch∆∞a c√≥ linh th√∫ n√†o ƒë·ªÉ th√¥n ph·ªá!');
    return;
  }

  const cooldownTime = checkCooldown(userId, 'linhthu');
  if (cooldownTime > 0) {
    const hours = Math.floor(cooldownTime / 3600);
    const minutes = Math.floor((cooldownTime % 3600) / 60);
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${hours}h${minutes}m n·ªØa ƒë·ªÉ th√¥n ph·ªá ti·∫øp.`);
    return;
  }

  // T√¨m linh th√∫ ƒë·ªÉ th√¥n ph·ªá
  const success = Math.random() < 0.4; // 40% c∆° h·ªôi th√†nh c√¥ng
  if (success) {
    const expGain = Math.floor(Math.random() * 50) + 50;
    userData.linhThu.exp += expGain;
    
    // Ki·ªÉm tra level up cho linh th√∫
    if (userData.linhThu.exp >= userData.linhThu.level * 150) {
      userData.linhThu.level += 1;
      userData.linhThu.exp = 0;
      userData.linhThu.power += 20;
      
      message.reply(`üéä Ch√∫c m·ª´ng! ${userData.linhThu.name} ƒë√£ ƒë·ªôt ph√° l√™n c·∫•p ${userData.linhThu.level}!\nüí™ S·ª©c m·∫°nh tƒÉng l√™n ${userData.linhThu.power}!`);
    } else {
      message.reply(`‚ú® Th√¥n ph·ªá th√†nh c√¥ng!\nüìä Linh th√∫ EXP +${expGain}\nüîã Linh th√∫ EXP: ${userData.linhThu.exp}/${userData.linhThu.level * 150}`);
    }
  } else {
    message.reply('‚ùå Th√¥n ph·ªá th·∫•t b·∫°i! H√£y th·ª≠ l·∫°i sau 24 gi·ªù.');
  }

  client.cooldowns.linhthu.set(userId, Date.now());
}

function handleLinhThuInfoCommand(message) {
  const userId = message.author.id;
  const userData = getUserData(userId);

  if (!userData.linhThu) {
    message.reply('‚ùå B·∫°n ch∆∞a c√≥ linh th√∫ n√†o!');
    return;
  }

  const linhThu = userData.linhThu;
  const powerContribution = (linhThu.power * 0.3).toFixed(1);
  
  message.reply(`
üêæ **Th√¥ng Tin Linh Th√∫**
T√™n: ${linhThu.name}
C·∫•p ƒë·ªô: ${linhThu.level}
Nguy√™n t·ªë: ${linhThu.element}
S·ª©c m·∫°nh: ${linhThu.power}
ƒê√≥ng g√≥p s·ª©c m·∫°nh: +${powerContribution} (30% s·ª©c m·∫°nh linh th√∫)
EXP: ${linhThu.exp}/${linhThu.level * 150}
  `);
}

function handleBiCanhCommand(message) {
  const userId = message.author.id;
  const cooldownTime = checkCooldown(userId, 'bicanh');
  
  if (cooldownTime > 0) {
    const hours = Math.floor(cooldownTime / 3600);
    const minutes = Math.floor((cooldownTime % 3600) / 60);
    message.reply(`B·∫°n c·∫ßn ƒë·ª£i ${hours}h${minutes}m n·ªØa ƒë·ªÉ kh√°m ph√° b√≠ c·∫£nh ti·∫øp.`);
    return;
  }

  const userData = getUserData(userId);
  const rewards = {
    exp: Math.floor(Math.random() * 200) + 100,
    coins: Math.floor(Math.random() * 100) + 100
  };
  
  userData.exp += rewards.exp;
  userData.coins += rewards.coins;
  
  message.reply(`üèØ Kh√°m ph√° b√≠ c·∫£nh th√†nh c√¥ng!\nüìä EXP +${rewards.exp}\nüí∞ Coins +${rewards.coins}\nüîã EXP hi·ªán t·∫°i: ${userData.exp}/${userData.level * 100}\nüëõ Coins hi·ªán t·∫°i: ${userData.coins}`);
  client.cooldowns.bicanh.set(userId, Date.now());
}

function formatCooldown(seconds) {
  if (seconds <= 0) return '‚úÖ S·∫µn s√†ng';
  
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const remainingSeconds = seconds % 60;
  
  if (hours > 0) return `‚è≥ ${hours}h${minutes}m`;
  if (minutes > 0) return `‚è≥ ${minutes}m${remainingSeconds}s`;
  return `‚è≥ ${remainingSeconds}s`;
}

// Start server and login bot
keepAlive();
client.login(process.env.TOKEN);
